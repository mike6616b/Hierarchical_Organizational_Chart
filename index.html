<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>組織架構圖</title>

  <!-- d3 只保留用來計算 tree 版位 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- PixiJS + Viewport for WebGL rendering & pan/zoom -->
  <script src="https://unpkg.com/pixi.js@7/dist/pixi.min.js"></script>
  <script src="https://unpkg.com/pixi-viewport@5.0.3/dist/umd/pixi-viewport.umd.min.js"></script>

  <style>
    :root { --bg:#f5f6fa; --card:#fff; --ink:#2c3e50; --muted:#7f8c8d; }
    *{box-sizing:border-box}
    body{ margin:0; font-family:'Noto Sans TC','Microsoft JhengHei',system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; background:var(--bg) }

    .container{max-width:1400px;margin:16px auto;background:var(--card);border-radius:12px;box-shadow:0 4px 14px rgba(0,0,0,.08);overflow:hidden}
    .header{position:relative;padding:20px;color:#fff;background:linear-gradient(135deg,#2c3e50 0%,#3498db 100%)}
    .header h1{margin:0 0 6px;font-size:22px}
    .header p{margin:0;opacity:.9}
    .date-filter{position:absolute;top:16px;right:16px;display:flex;gap:6px;flex-wrap:wrap;align-items:center;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.25);backdrop-filter:blur(10px);border-radius:10px;padding:10px}
    .date-filter input[type="date"],.date-filter input[type="text"]{width:160px;padding:8px;border:none;border-radius:6px;background:rgba(255,255,255,.95);font-size:12px}
    .date-filter button{padding:8px 12px;border:none;border-radius:6px;background:#27ae60;color:#fff;font-size:12px;cursor:pointer}
    .chart-container{padding:16px;text-align:center;position:relative}
    .instructions{background:linear-gradient(135deg,#e8f5e8 0%,#f0f8ff 100%);border:1px solid #27ae60;color:var(--ink);padding:12px;border-radius:10px;margin:0 0 12px;font-size:13px}

    .stats-summary{display:flex;justify-content:space-around;gap:8px;flex-wrap:wrap;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);color:#fff;padding:14px;border-radius:10px;margin-top:12px}
    .stat-item{text-align:center}
    .stat-value{font-size:22px;font-weight:800;display:block}
    .stat-label{font-size:12px;opacity:.9}

    /* chart 容器：Pixi 的 <canvas> 會塞進這裡 */
    #chart{ position:relative; width:100%; height:70vh; }
    #zoomControls{ position:absolute; top:8px; right:8px; display:flex; gap:6px; z-index:3; }
    #zoomControls button{ padding:4px 8px; border-radius:6px; font-size:12px; }

    /* 圖例點點 */
    .dot{ display:inline-block; width:12px; height:12px; border-radius:50%; border:2px solid; vertical-align:middle }
    .dot-dealer{ background:#5582b4; border-color:#3f668e }   /* 經銷商 */
    .dot-level{  background:#f7959d; border-color:#d86a74 }   /* 高/中/初級 */
    .dot-normal{ background:#deabe9; border-color:#b687c8 }   /* 一般 */
    .dot-high{   background:#ffffff; border-color:#fff600 }   /* 高業績 */
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>組織架構圖</h1>
      <p>點擊節點展開下線組織，查看各階段業績表現</p>
      <div class="date-filter">
        <input type="date" id="startDate" value="2025-01-01" />
        <input type="date" id="endDate" value="2025-08-15" />
        <button id="btnApply">更新數據</button>
        <input type="text" id="searchName" placeholder="搜尋人名" />
        <button id="btnSearch"  style="background:#3b82f6">搜尋</button>
        <button id="btnClear"   style="background:#f51111">清除</button>
        <button id="btnExpand"  style="background:#6b7280">展開</button>
        <button id="btnLocate"  style="background:#0ea5e9">定位</button> <!-- 新增：將搜尋對象置中偏上 -->
      </div>
    </div>

    <div class="chart-container">
      <div class="instructions">
        使用日期區間與搜尋人名
        <div>
          <span class="dot dot-dealer"></span> 經銷商　
          <span class="dot dot-level"></span> 高/中/初級　
          <span class="dot dot-normal"></span> 一般　
          <span class="dot dot-high"></span> 高業績（月均訂貨 ≥ 106萬）
        </div>
      </div>

      <div id="chart">
        <div id="zoomControls">
          <button id="btnZoomIn">＋</button>
          <button id="btnZoomOut">－</button>
          <button id="btnFit">Fit</button>
        </div>
      </div>

      <div class="stats-summary">
        <div class="stat-item"><span class="stat-value" id="totalOrders">0</span><span class="stat-label">總訂貨金額 (萬元)</span></div>
        <div class="stat-item"><span class="stat-value" id="totalPickup">0</span><span class="stat-label">總提貨金額 (萬元)</span></div>
        <div class="stat-item"><span class="stat-value" id="totalMembers">0</span><span class="stat-label">組織總人數</span></div>
        <div class="stat-item"><span class="stat-value" id="highPerformers">0</span><span class="stat-label">高業績會員</span></div>
      </div>
    </div>
  </div>

<script>
/* =======================================================================================
   1) 資料層：隨機產生組織 + 直接在節點寫入 order/pickup（避免 NaN）
   ======================================================================================= */

function generateOrgTree(opts = {}) {
  const {
    seed = Date.now(),
    dealers = 3,
    depth = 6,
    branching = { dealer:[3,5], senior:[2,4], mid:[2,4], junior:[2,4], general:[0,0] },
    perfByLevel = {
      ROOT:{ order:[0,0], pickupRatio:[0,0] },
      經銷商:{ order:[350,500], pickupRatio:[0.65,0.9] },
      高級:{ order:[120,220], pickupRatio:[0.6,0.9] },
      中級:{ order:[60,110],  pickupRatio:[0.55,0.9] },
      初級:{ order:[40,80],   pickupRatio:[0.5,0.85] },
      一般:{ order:[18,40],   pickupRatio:[0.5,0.8] }
    }
  } = opts;

  function mulberry32(a){return function(){let t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296}}
  const rnd = mulberry32(hashSeed(seed));
  function hashSeed(s){ if(typeof s==='string'){let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619)} return h>>>0 } return s>>>0 }

  const pick = arr => arr[Math.floor(rnd()*arr.length)];
  const randInt = (min,max)=>Math.floor(rnd()*(max-min+1))+min;
  const randFloat = (min,max)=>rnd()*(max-min)+min;

  const lastNames = '李王張劉陳楊黃趙周吳徐孫朱馬胡郭林何高梁鄭羅宋謝唐韓曹許鄧蕭馮曾潘蔡蔣袁於杜葉蘇魏呂丁沈姜範盧賈傅鐘白汪錢廖湯文嚴石黎薛金滕康田顧孟方尹江史'.split('');
  const givenA = '小大中安宥冠柏哲孟家雅怡佩芯志庭宸思凱承博俊品語彤婉筑妍筠苑昀'.split('');
  const givenB = '明偉豪霖諾瑜欣柔雯庭賢傑瑋均蓉華潔媛婷安甄翔宇洋恩熒雲淇'.split('');
  const randName = ()=> pick(lastNames) + pick(givenA) + pick(givenB);

  const prefixByLevel = { ROOT:'ROOT', 經銷商:'CEO', 高級:'R', 中級:'T', 初級:'M', 一般:'U' };
  const idCounters = new Map();
  const nextId = p => { const n=(idCounters.get(p)||0)+1; idCounters.set(p,n); return p+String(n).padStart(3,'0'); };

  function drawMetrics(level){
    const conf = perfByLevel[level] || { order:[0,0], pickupRatio:[0,0] };
    const order = randInt(conf.order[0], conf.order[1]);
    const ratio = Math.max(0, Math.min(1, randFloat(conf.pickupRatio[0], conf.pickupRatio[1])));
    const pickup = Math.min(order, Math.round(order*ratio));
    return { order, pickup };
  }

  function makeNode(level){
    const id = nextId(prefixByLevel[level] || 'N');
    const name = randName();
    const {order, pickup} = drawMetrics(level);
    return { id, name, level, order, pickup, 訂貨:order, 提貨:pickup };
  }

  function childrenPlan(level){
    switch(level){
      case '經銷商': return { next:['高級','中級'], key:'dealer' };
      case '高級':   return { next:['中級','初級'], key:'senior' };
      case '中級':   return { next:['初級','一般'], key:'mid' };
      case '初級':   return { next:['一般'], key:'junior' };
      default:       return { next:[], key:null };
    }
  }

  const root = { id:'ROOT', name:'ROOT', level:'ROOT', order:0, pickup:0, children:[] };
  for(let i=0;i<dealers;i++) root.children.push(makeNode('經銷商'));

  // BFS 擴展
  const q = root.children.map(n=>({node:n, depth:2}));
  while(q.length){
    const {node, depth:d} = q.shift();
    if(d >= depth) continue;
    const plan = childrenPlan(node.level);
    if(!plan.key) continue;
    const [minB,maxB] = branching[plan.key];
    const count = randInt(minB,maxB);
    if(count<=0) continue;
    node.children=[];
    for(let i=0;i<count;i++){
      const lv = pick(plan.next);
      const c = makeNode(lv);
      node.children.push(c);
      q.push({node:c, depth:d+1});
    }
  }
  return { treeData:root };
}

/* =======================================================================================
   2) 共用工具/狀態
   ======================================================================================= */

const HIGH_THRESHOLD = 106; // 高業績門檻（以「萬」為單位）

const { treeData } = generateOrgTree({ seed:'pixi-demo' });
let root;                    // d3.hierarchy
let treeLayout;              // d3.tree
let highlightIds = null;     // Set<string> | null
let searchKeyword = '';      // 目前搜尋字串

// 版位間距
const XGAP = 90;
const YGAP = 110;

// 只收集目前可見節點（children 展開的）
function collectVisible(n,out){ if(n.depth>0) out.push(n); if(n.children) n.children.forEach(c=>collectVisible(c,out)); }
function getVisibleNodes(){ const arr=[]; collectVisible(root,arr); return arr; }

// 折疊/展開
function collapse(n){ if(n.children){ n._children = n.children; n._children.forEach(collapse); n.children = null; } }
function toggle(d){ if(d.children){ d._children = d.children; d._children.forEach(collapse); d.children = null; } else { d.children = d._children; d._children = null; } }
function expandNode(d){ if(d._children){ d.children=d._children; d._children=null; } }
function expandAncestors(d){ let p=d; while(p){ expandNode(p); p=p.parent; } }
function expandSubtree(d){ expandNode(d); if(d.children) d.children.forEach(expandSubtree); }

function shouldDim(d){ if(!highlightIds) return false; return !highlightIds.has(d.data.id); }
function isHigh(d){ return (d?.data?.order ?? 0) >= HIGH_THRESHOLD; }

/* =======================================================================================
   3) PixiJS / Viewport 初始化  [PIX I]
   ======================================================================================= */

  // 把各種 UMD 變體整理成同一個全域 __Viewport__
  window.__Viewport__ =
    (window.pixi_viewport && (window.pixi_viewport.Viewport || window.pixi_viewport.default || window.pixi_viewport)) ||
    (window.PIXI && window.PIXI.viewport && (window.PIXI.viewport.Viewport || window.PIXI.viewport.default)) ||
    window.Viewport;
  
(async () => {
const chartEl = document.getElementById('chart');

let app;
// v7 走這裡：Application.prototype.init 存在
if (PIXI.Application && PIXI.Application.prototype && 'init' in PIXI.Application.prototype) {
  app = new PIXI.Application();
  await app.init({ resizeTo: chartEl, antialias: true, backgroundAlpha: 0 });
  chartEl.appendChild(app.canvas);
} else {
  // v6 走這裡
  app = new PIXI.Application({ resizeTo: chartEl, antialias: true, backgroundAlpha: 0 });
  chartEl.appendChild(app.view);
}

// 事件來源：v7 是 renderer.events；v6 是 renderer.plugins.interaction
// 事件來源（v7 / v6 相容）
const events = app.renderer.events || (app.renderer.plugins && app.renderer.plugins.interaction);

// 直接用正規化後的建構子
const ViewportCtor = window.__Viewport__;
if (!ViewportCtor) throw new Error('pixi-viewport UMD 未載入成功');

const viewport = new ViewportCtor({
  screenWidth: app.renderer.width,
  screenHeight: app.renderer.height,
  worldWidth: 8000,
  worldHeight: 8000,
  events,
  ticker: app.ticker
});
app.stage.addChild(viewport);

// 啟用手勢
viewport.drag().pinch().wheel().decelerate();

// 兩層容器：連線在下、節點在上
const linkLayer = new PIXI.Container();
const nodeLayer = new PIXI.Container();
viewport.addChild(linkLayer, nodeLayer);

// 快取
const linkById = new Map(); // id -> Graphics
const nodeById = new Map(); // id -> {container, circle, name, level, tOrder, tPickup}

/* =======================================================================================
   4) d3 tree 版位 + 首次初始化  [D3 Layout]
   ======================================================================================= */

treeLayout = d3.tree().nodeSize([XGAP, YGAP]).separation((a,b)=> (a.parent===b.parent ? 1.2 : 1.8));

async function init(){
  root = d3.hierarchy(treeData, d=>d.children);

  // 預設：只顯示第一層（經銷商）；經銷商以下全部折疊
  if (root.children) root.children.forEach(collapse);

  update();       // 計算版位 + Pixi 繪圖
  updateSummary();
  fitToContent();

  // 初始 fit 到視窗並稍微上移
  viewport.fit(true);
  viewport.move(0, -80);
}
init();

/* =======================================================================================
   5) 繪圖：用 Pixi 取代原 SVG 的 update() 畫圖段
   ======================================================================================= */

// 顏色對應
function levelFill(l){ if(l==='經銷商')return 0x5582b4; if(l==='高級'||l==='中級'||l==='初級')return 0xf7959d; if(l==='一般')return 0xdeabe9; return 0xcccccc; }
function levelStroke(l){ if(l==='經銷商')return 0x3f668e; if(l==='高級'||l==='中級'||l==='初級')return 0xd86a74; if(l==='一般')return 0xb687c8; return 0x999999; }

// 畫貝茲曲線（等同原 SVG path）
function drawLink(id, x1,y1, x2,y2, dim){
  let g = linkById.get(id);
  if(!g){ g = new PIXI.Graphics(); linkById.set(id,g); linkLayer.addChild(g); }
  g.clear();
  g.lineStyle(2, 0xbdc3c7, dim?0.5:0.85);
  const cmy = (y1+y2)/2;
  g.moveTo(x1,y1);
  g.bezierCurveTo(x1,cmy, x2,cmy, x2,y2);
}

function ensureNode(d){
  let e = nodeById.get(d.data.id);
  if (e) return e;

  const circle = new PIXI.Graphics();
  const name   = new PIXI.Text('', {fontSize:14, fill:0x2c3e50, fontWeight:'bold'});
  const level  = new PIXI.Text('', {fontSize:11, fill:0x7f8c8d});
  const tOrder = new PIXI.Text('', {fontSize:10, fill:0x27ae60, fontWeight:'bold'});
  const tPickup= new PIXI.Text('', {fontSize:10, fill:0x8e44ad, fontWeight:'bold'});
  name.anchor.set(0.5); level.anchor.set(0.5); tOrder.anchor.set(0.5); tPickup.anchor.set(0.5);
  name.y=-28; level.y=-14; tOrder.y=18; tPickup.y=32;

  const container = new PIXI.Container();
  container.interactive = true;
  container.cursor = 'pointer';
  container.on('pointertap', async ()=>{
    toggle(d);
    update();        // 版位 + 重繪
    updateSummary();
    fitToContent();
  });

  container.addChild(circle, name, level, tOrder, tPickup);
  nodeLayer.addChild(container);

  e = { container, circle, name, level, tOrder, tPickup };
  nodeById.set(d.data.id, e);
  return e;
}

// 中心定位：把節點移到畫面中間偏上
function centerOnNode(d, topPad=80){
  if(!d) return;
  const k = viewport.scale.x; // 保持當前縮放
  viewport.animate({ time: 500, ease:'easeInOutSine', position: new PIXI.Point(d.x, d.y), scale: new PIXI.Point(k,k) });
  viewport.moveCenter(d.x, d.y);
  viewport.move(0, -(app.renderer.height/2 - topPad));
}

// 讓目前「可見節點」自動縮放並置中，且往上貼一點
function fitToContent(padTop = 80, padLR = 40, bump = 1.15) {
  const nodes = getVisibleNodes();
  if (!nodes.length) {
    viewport.fit(true);
    viewport.move(0, -padTop);
    return;
  }

  // 計算可見節點的包圍盒
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const d of nodes) {
    if (d.x < minX) minX = d.x;
    if (d.x > maxX) maxX = d.x;
    if (d.y < minY) minY = d.y;
    if (d.y > maxY) maxY = d.y;
  }
  const w = Math.max(1, maxX - minX);
  const h = Math.max(1, maxY - minY);

  const sw = app.renderer.width;
  const sh = app.renderer.height;

  // 計算縮放，保留左右/上邊距
  const kBase = Math.min(
    (sw - padLR * 2) / w,
    (sh - (padTop + padLR)) / h
  );
  const k = Math.max(0.2, Math.min(3, kBase * bump));

  // 內容中心
  const cx = (minX + maxX) / 2;
  const cy = (minY + maxY) / 2;

  // 動畫帶入位置與縮放，之後再往上推 padTop
  viewport.animate({
    time: 400,
    position: new PIXI.Point(cx, cy),
    scale: new PIXI.Point(k, k),
    ease: 'easeInOutSine'
  }).once('moved', () => {
    viewport.moveCenter(cx, cy);
    viewport.move(0, -(sh / 2 - padTop));
  });
}

// 版位計算 + Pixi 重繪（取代原 SVG 的 update()）
function update(){
  treeLayout(root);
  const nodes = getVisibleNodes();
  const links = nodes.filter(d=> d.parent && d.parent.depth>0);

  // 清理：標記活躍 id，順便移除不再可見的 Pixi 物件（簡易 GC）
  const liveNodeIds = new Set(nodes.map(d=>d.data.id));
  const liveLinkIds = new Set(links.map(d=>d.data.id));

  for(const [id,g] of linkById){
    if(!liveLinkIds.has(id)){ g.destroy({children:true}); linkById.delete(id); }
  }
  for(const [id,e] of nodeById){
    if(!liveNodeIds.has(id)){ e.container.destroy({children:true}); nodeById.delete(id); }
  }

  // 畫連線
  for(const d of links){
    const dim = shouldDim(d) || shouldDim(d.parent);
    drawLink(d.data.id, d.parent.x, d.parent.y, d.x, d.y, dim);
  }

  // 畫節點
  for(const d of nodes){
    const dim = shouldDim(d);
    const e = ensureNode(d);

    e.container.position.set(d.x, d.y);
    e.container.alpha = dim ? 0.3 : 1.0;

    const fill = levelFill(d.data.level);
    const stroke = isHigh(d) ? 0xfff600 : levelStroke(d.data.level);
    const strokeW = isHigh(d) ? 3 : 2;

    e.circle.clear().lineStyle(strokeW, stroke, 1).beginFill(fill,1).drawCircle(0,0,8).endFill();
    e.name.text   = d.data.name;
    e.level.text  = d.data.level || '';
    e.tOrder.text = `訂貨：${Math.round(d.data.order||0)}萬`;
    e.tPickup.text= `提貨：${Math.round(d.data.pickup||0)}萬`;
  }
}

/* =======================================================================================
   6) 搜尋 / 清除 / 展開 / 定位
   ======================================================================================= */

// 搜尋：命中節點 + 其所有祖先/子孫保持高亮，其餘淡化
function applySearch(){
  const q = (document.getElementById('searchName').value||'').trim();
  searchKeyword = q;
  if(!q){ highlightIds=null; update(); updateSummary(); return; }

  // 建索引（含未展開子孫）
  const all=[]; (function walk(n){ all.push(n); (n.children||[]).forEach(walk); (n._children||[]).forEach(walk); })(root);
  const hits=all.filter(n=> (n.data.name||'').includes(q));
  if(!hits.length){ highlightIds=new Set(); update(); updateSummary(); return; }

  const keep=new Set();
  const addAnc=(n)=>{ let cur=n; while(cur){ keep.add(cur.data.id); cur=cur.parent; } };
  const addDesc=(n)=>{ (function dfs(x){ keep.add(x.data.id); (x.children||[]).forEach(dfs); (x._children||[]).forEach(dfs); })(n); };
  for(const h of hits){ addAnc(h); addDesc(h); }
  keep.delete('ROOT');
  highlightIds=keep;

  update();
  updateSummary();
}

// 展開：把目前搜尋命中的節點展開（祖先 + 子孫）
function expandSearchTargets(){
  const kw = (searchKeyword||'').trim();
  if(!kw) return;
  const all=[]; (function walk(n){ all.push(n); (n.children||[]).forEach(walk); (n._children||[]).forEach(walk); })(root);
  const matches = all.filter(n => (n.data.name||'').includes(kw));
  matches.forEach(n => { expandAncestors(n); expandSubtree(n); });
  update();
  updateSummary();
  fitToContent();
}

// 定位：把目前搜尋命中的第一個節點移到中間偏上
function locateFirstMatch(){
  const kw = (searchKeyword||'').trim();
  if(!kw) return;
  const all=[]; (function walk(n){ all.push(n); (n.children||[]).forEach(walk); (n._children||[]).forEach(walk); })(root);
  const match = all.find(n => (n.data.name||'').includes(kw));
  if(match){
    expandAncestors(match); // 需要展開祖先，確保在可視
    update();
    centerOnNode(match, 80);
  }
}

/* =======================================================================================
   7) 摘要統計（同原本邏輯，掃描目前“未淡化”的可見節點）
   ======================================================================================= */

function updateSummary(){
  let nodes=getVisibleNodes();
  if (highlightIds) nodes = nodes.filter(d => !shouldDim(d));

  let totalOrders=0,totalPickup=0,totalMembers=0,high=0;
  for(const n of nodes){
    if(n.depth===0) continue;
    totalMembers++;
    const order  = n.data.order  ?? 0;
    const pickup = n.data.pickup ?? 0;
    totalOrders += order;
    totalPickup += pickup;
    if (order >= HIGH_THRESHOLD) high++;
  }
  document.getElementById('totalOrders').textContent=totalOrders.toLocaleString();
  document.getElementById('totalPickup').textContent=totalPickup.toLocaleString();
  document.getElementById('totalMembers').textContent=totalMembers;
  document.getElementById('highPerformers').textContent=high;
}

/* =======================================================================================
   8) 事件綁定（日期目前僅做演示；若之後要串 API，再在這裡觸發重算）
   ======================================================================================= */

document.getElementById('btnApply').addEventListener('click', ()=>{
  // TODO: 接後端時，依日期重新拉績效後呼叫 update()/updateSummary()
  update(); updateSummary();
});
document.getElementById('btnSearch').addEventListener('click', ()=>{
  applySearch();
  fitToContent();  // << 新增
});
document.getElementById('btnClear').addEventListener('click', ()=>{
  document.getElementById('searchName').value='';
  searchKeyword=''; highlightIds=null; 
  update(); 
  updateSummary();
  fitToContent();
});
document.getElementById('btnExpand').addEventListener('click', expandSearchTargets);
document.getElementById('btnLocate').addEventListener('click', locateFirstMatch);

// 即時輸入也更新淡化（可留可關）
document.getElementById('searchName').addEventListener('input', ()=>{
  applySearch();
});

// Zoom 控制
document.getElementById('btnZoomIn').addEventListener('click', ()=> viewport.setZoom(viewport.scale.x * 1.2, true));
document.getElementById('btnZoomOut').addEventListener('click',()=> viewport.setZoom(viewport.scale.x / 1.2, true));
document.getElementById('btnFit').addEventListener('click', ()=> fitToContent());

/* =======================================================================================
   9) 之後的效能升級建議（已標註 TODO 的位置）
   ---------------------------------------------------------------------------------------
   - 物件池化：node/link 對象可放回池而不是 destroy（減少 GC）。
   - 虛擬渲染：只渲染視窗附近的節點與相連邊（可用 viewport.getVisibleBounds()）。
   - 文字批量：名稱/數字可改 BitmapFont（Pixi 支援），大量節點時更省。
   - 線段圖層：大量邊可改 mesh 或用細分度更低的曲線/直線。
   ======================================================================================= */
})();
  
</script>
</body>
</html>
